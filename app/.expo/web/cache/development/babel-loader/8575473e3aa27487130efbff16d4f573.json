{"ast":null,"code":"'use strict';\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport base64js from 'base64-js';\nimport hexLite from 'hex-lite';\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\n\nfunction convertArrayBufferToUtf8(arrayBuffer) {\n  var array = new Uint8Array(arrayBuffer);\n  var chars = [];\n  var i = 0;\n\n  while (i < array.length) {\n    var byte = array[i];\n\n    if (byte < 128) {\n      chars.push(String.fromCharCode(byte));\n      i++;\n    } else if (byte > 191 && byte < 224) {\n      chars.push(String.fromCharCode((byte & 0x1f) << 6 | array[i + 1] & 0x3f));\n      i += 2;\n    } else {\n      chars.push(String.fromCharCode((byte & 0x0f) << 12 | (array[i + 1] & 0x3f) << 6 | array[i + 2] & 0x3f));\n      i += 3;\n    }\n  }\n\n  return chars.join('');\n}\n\nfunction convertUtf8ToArrayBuffer(utf8) {\n  var bytes = [];\n  var i = 0;\n  utf8 = encodeURI(utf8);\n\n  while (i < utf8.length) {\n    var byte = utf8.charCodeAt(i++);\n\n    if (byte === 37) {\n      bytes.push(parseInt(utf8.substr(i, 2), 16));\n      i += 2;\n    } else {\n      bytes.push(byte);\n    }\n  }\n\n  var array = new Uint8Array(bytes);\n  return array.buffer;\n}\n\nfunction convertArrayBufferToBase64(arrayBuffer) {\n  return base64js.fromByteArray(new Uint8Array(arrayBuffer));\n}\n\nfunction convertBase64ToArrayBuffer(base64) {\n  return base64js.toByteArray(base64).buffer;\n}\n\nvar convertArrayBufferToHex = hexLite.fromBuffer;\nvar convertHexToArrayBuffer = hexLite.toBuffer;\n\nfunction randomBytes(length) {\n  return _regeneratorRuntime.async(function randomBytes$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.t0 = convertBase64ToArrayBuffer;\n          _context.next = 3;\n          return _regeneratorRuntime.awrap(NativeModules.RNSCRandomBytes.randomBytes(length));\n\n        case 3:\n          _context.t1 = _context.sent;\n          return _context.abrupt(\"return\", (0, _context.t0)(_context.t1));\n\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction SHAWrapper(data, algorithm) {\n  var dataBase64, result;\n  return _regeneratorRuntime.async(function SHAWrapper$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          if (!(typeof data === 'string')) {\n            _context2.next = 4;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", NativeModules.RNSCSha.shaUtf8(data, algorithm));\n\n        case 4:\n          dataBase64 = convertArrayBufferToBase64(data);\n          _context2.next = 7;\n          return _regeneratorRuntime.awrap(NativeModules.RNSCSha.shaBase64(dataBase64, algorithm));\n\n        case 7:\n          result = _context2.sent;\n          return _context2.abrupt(\"return\", convertBase64ToArrayBuffer(result));\n\n        case 9:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nvar AES = {\n  encrypt: function encrypt(textArrayBuffer, keyArrayBuffer, ivArrayBuffer) {\n    var textBase64, keyHex, ivHex;\n    return _regeneratorRuntime.async(function encrypt$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            textBase64 = convertArrayBufferToBase64(textArrayBuffer);\n            keyHex = convertArrayBufferToHex(keyArrayBuffer);\n            ivHex = convertArrayBufferToHex(ivArrayBuffer);\n            _context3.t0 = convertBase64ToArrayBuffer;\n            _context3.next = 6;\n            return _regeneratorRuntime.awrap(NativeModules.RNSCAes.encrypt(textBase64, keyHex, ivHex));\n\n          case 6:\n            _context3.t1 = _context3.sent;\n            return _context3.abrupt(\"return\", (0, _context3.t0)(_context3.t1));\n\n          case 8:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  decrypt: function decrypt(cipherTextArrayBuffer, keyArrayBuffer, ivArrayBuffer) {\n    var cipherTextBase64, keyHex, ivHex;\n    return _regeneratorRuntime.async(function decrypt$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            cipherTextBase64 = convertArrayBufferToBase64(cipherTextArrayBuffer);\n            keyHex = convertArrayBufferToHex(keyArrayBuffer);\n            ivHex = convertArrayBufferToHex(ivArrayBuffer);\n            _context4.t0 = convertBase64ToArrayBuffer;\n            _context4.next = 6;\n            return _regeneratorRuntime.awrap(NativeModules.RNSCAes.decrypt(cipherTextBase64, keyHex, ivHex));\n\n          case 6:\n            _context4.t1 = _context4.sent;\n            return _context4.abrupt(\"return\", (0, _context4.t0)(_context4.t1));\n\n          case 8:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }\n};\nvar SHA = {\n  sha1: function sha1(data) {\n    return SHAWrapper(data, 'SHA-1');\n  },\n  sha256: function sha256(data) {\n    return SHAWrapper(data, 'SHA-256');\n  },\n  sha512: function sha512(data) {\n    return SHAWrapper(data, 'SHA-512');\n  }\n};\nvar HMAC = {\n  hmac256: function hmac256(textArrayBuffer, keyArrayBuffer) {\n    var textHex, keyHex, signatureHex;\n    return _regeneratorRuntime.async(function hmac256$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            textHex = convertArrayBufferToHex(textArrayBuffer);\n            keyHex = convertArrayBufferToHex(keyArrayBuffer);\n            _context5.next = 4;\n            return _regeneratorRuntime.awrap(NativeModules.RNSCHmac.hmac256(textHex, keyHex));\n\n          case 4:\n            signatureHex = _context5.sent;\n            return _context5.abrupt(\"return\", convertHexToArrayBuffer(signatureHex));\n\n          case 6:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }\n};\nvar PBKDF2 = {\n  hash: function hash(password, salt, iterations, keyLength, algorithm) {\n    var passwordToHash, saltToHash, digest;\n    return _regeneratorRuntime.async(function hash$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            passwordToHash = password;\n            saltToHash = salt;\n\n            if (typeof password === 'string') {\n              passwordToHash = convertUtf8ToArrayBuffer(password);\n            }\n\n            if (typeof salt === 'string') {\n              saltToHash = convertUtf8ToArrayBuffer(salt);\n            }\n\n            _context6.next = 6;\n            return _regeneratorRuntime.awrap(NativeModules.RNSCPbkdf2.hash(convertArrayBufferToBase64(passwordToHash), convertArrayBufferToBase64(saltToHash), iterations, keyLength, algorithm));\n\n          case 6:\n            digest = _context6.sent;\n            return _context6.abrupt(\"return\", convertBase64ToArrayBuffer(digest));\n\n          case 8:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }\n};\nvar RSA = NativeModules.RNSCRsa;\nvar utils = {\n  randomBytes: randomBytes,\n  convertArrayBufferToUtf8: convertArrayBufferToUtf8,\n  convertUtf8ToArrayBuffer: convertUtf8ToArrayBuffer,\n  convertArrayBufferToBase64: convertArrayBufferToBase64,\n  convertBase64ToArrayBuffer: convertBase64ToArrayBuffer,\n  convertArrayBufferToHex: convertArrayBufferToHex,\n  convertHexToArrayBuffer: convertHexToArrayBuffer\n};\nexport default {\n  AES: AES,\n  SHA: SHA,\n  HMAC: HMAC,\n  PBKDF2: PBKDF2,\n  RSA: RSA,\n  utils: utils\n};","map":{"version":3,"sources":["/home/titan/try-again/app/node_modules/react-native-simple-crypto/index.js"],"names":["base64js","hexLite","convertArrayBufferToUtf8","arrayBuffer","array","Uint8Array","chars","i","length","byte","push","String","fromCharCode","join","convertUtf8ToArrayBuffer","utf8","bytes","encodeURI","charCodeAt","parseInt","substr","buffer","convertArrayBufferToBase64","fromByteArray","convertBase64ToArrayBuffer","base64","toByteArray","convertArrayBufferToHex","fromBuffer","convertHexToArrayBuffer","toBuffer","randomBytes","NativeModules","RNSCRandomBytes","SHAWrapper","data","algorithm","RNSCSha","shaUtf8","dataBase64","shaBase64","result","AES","encrypt","textArrayBuffer","keyArrayBuffer","ivArrayBuffer","textBase64","keyHex","ivHex","RNSCAes","decrypt","cipherTextArrayBuffer","cipherTextBase64","SHA","sha1","sha256","sha512","HMAC","hmac256","textHex","RNSCHmac","signatureHex","PBKDF2","hash","password","salt","iterations","keyLength","passwordToHash","saltToHash","RNSCPbkdf2","digest","RSA","RNSCRsa","utils"],"mappings":"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","sourcesContent":["'use strict';\n\nimport base64js from 'base64-js';\nimport hexLite from 'hex-lite';\nimport { NativeModules } from 'react-native';\n\nfunction convertArrayBufferToUtf8(arrayBuffer) {\n  const array = new Uint8Array(arrayBuffer);\n  const chars = [];\n  let i = 0;\n\n  while (i < array.length) {\n    const byte = array[i];\n    if (byte < 128) {\n      chars.push(String.fromCharCode(byte));\n      i++;\n    } else if (byte > 191 && byte < 224) {\n      chars.push(\n        String.fromCharCode(((byte & 0x1f) << 6) | (array[i + 1] & 0x3f))\n      );\n      i += 2;\n    } else {\n      chars.push(\n        String.fromCharCode(\n          ((byte & 0x0f) << 12) |\n          ((array[i + 1] & 0x3f) << 6) |\n          (array[i + 2] & 0x3f)\n        )\n      );\n      i += 3;\n    }\n  }\n\n  return chars.join('');\n}\n\nfunction convertUtf8ToArrayBuffer(utf8) {\n  const bytes = [];\n\n  let i = 0;\n  utf8 = encodeURI(utf8);\n  while (i < utf8.length) {\n    const byte = utf8.charCodeAt(i++);\n    if (byte === 37) {\n      bytes.push(parseInt(utf8.substr(i, 2), 16));\n      i += 2;\n    } else {\n      bytes.push(byte);\n    }\n  }\n\n  const array = new Uint8Array(bytes);\n  return array.buffer;\n}\n\nfunction convertArrayBufferToBase64(arrayBuffer) {\n  return base64js.fromByteArray(new Uint8Array(arrayBuffer));\n}\n\nfunction convertBase64ToArrayBuffer(base64) {\n  return base64js.toByteArray(base64).buffer;\n}\n\nconst convertArrayBufferToHex = hexLite.fromBuffer;\n\nconst convertHexToArrayBuffer = hexLite.toBuffer;\n\nasync function randomBytes(length) {\n  return convertBase64ToArrayBuffer(await NativeModules.RNSCRandomBytes.randomBytes(length));\n}\n\nasync function SHAWrapper(data, algorithm) {\n  if (typeof data === 'string') {\n    return NativeModules.RNSCSha.shaUtf8(data, algorithm);\n  } else {\n    const dataBase64 = convertArrayBufferToBase64(data);\n    const result = await NativeModules.RNSCSha.shaBase64(dataBase64, algorithm);\n\n    return convertBase64ToArrayBuffer(result);\n  }\n}\n\nconst AES = {\n  encrypt: async function (textArrayBuffer, keyArrayBuffer, ivArrayBuffer) {\n    const textBase64 = convertArrayBufferToBase64(textArrayBuffer);\n    const keyHex = convertArrayBufferToHex(keyArrayBuffer);\n    const ivHex = convertArrayBufferToHex(ivArrayBuffer);\n    return convertBase64ToArrayBuffer(await NativeModules.RNSCAes.encrypt(textBase64, keyHex, ivHex));\n  },\n  decrypt: async function (cipherTextArrayBuffer, keyArrayBuffer, ivArrayBuffer) {\n    const cipherTextBase64 = convertArrayBufferToBase64(cipherTextArrayBuffer);\n    const keyHex = convertArrayBufferToHex(keyArrayBuffer);\n    const ivHex = convertArrayBufferToHex(ivArrayBuffer);\n    return convertBase64ToArrayBuffer(await NativeModules.RNSCAes.decrypt(cipherTextBase64, keyHex, ivHex));\n  }\n};\n\nconst SHA = {\n  sha1: data => SHAWrapper(data, 'SHA-1'),\n  sha256: data => SHAWrapper(data, 'SHA-256'),\n  sha512: data => SHAWrapper(data, 'SHA-512')\n};\n\nconst HMAC = {\n  hmac256: async function (textArrayBuffer, keyArrayBuffer) {\n    const textHex = convertArrayBufferToHex(textArrayBuffer);\n    const keyHex = convertArrayBufferToHex(keyArrayBuffer);\n    const signatureHex = await NativeModules.RNSCHmac.hmac256(textHex, keyHex);\n    return convertHexToArrayBuffer(signatureHex);\n  }\n};\n\nconst PBKDF2 = {\n  hash: async function (password, salt, iterations, keyLength, algorithm) {\n    let passwordToHash = password;\n    let saltToHash = salt;\n\n    if (typeof password === 'string') {\n      passwordToHash = convertUtf8ToArrayBuffer(password);\n    }\n\n    if (typeof salt === 'string') {\n      saltToHash = convertUtf8ToArrayBuffer(salt);\n    }\n\n    const digest = await NativeModules.RNSCPbkdf2.hash(\n      convertArrayBufferToBase64(passwordToHash),\n      convertArrayBufferToBase64(saltToHash),\n      iterations,\n      keyLength,\n      algorithm\n    );\n\n    return convertBase64ToArrayBuffer(digest);\n  }\n};\n\nconst RSA = NativeModules.RNSCRsa;\n\nconst utils = {\n  randomBytes,\n  convertArrayBufferToUtf8,\n  convertUtf8ToArrayBuffer,\n  convertArrayBufferToBase64,\n  convertBase64ToArrayBuffer,\n  convertArrayBufferToHex,\n  convertHexToArrayBuffer\n};\n\nexport default {\n  AES,\n  SHA,\n  HMAC,\n  PBKDF2,\n  RSA,\n  utils\n};\n"]},"metadata":{},"sourceType":"module"}